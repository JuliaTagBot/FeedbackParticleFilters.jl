var documenterSearchIndex = {"docs":
[{"location":"#FeedbackParticleFilters.jl-1","page":"Home","title":"FeedbackParticleFilters.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"A package for using feedback particle filters in nonlinear stochastic filtering and data assimilation problems.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\n \"getting_started.md\",\n]\nDepth = 1","category":"page"},{"location":"#What-are-feedback-particle-filters?-1","page":"Home","title":"What are feedback particle filters?","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Feedback particle filters (FPFs) are a class of sample-based numerical algorithms to approximate the conditional distribution in a nonlinear filtering problem. In contrast to conventional particle filters, which use importance weights, FPFs use feedback control to let the observations guide the particles to the appropriate position.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Further background reading:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\n \"filtering.md\",\n \"fpf.md\",\n]\nDepth = 1","category":"page"},{"location":"#Package-features-1","page":"Home","title":"Package features","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This package's aim is to provide a versatile and efficient feedback particle filter implementation in Julia, with abstractions to flexibly construct, run, and analyze feedback particle filters for a variety of uni- and multivariate filtering problems with both diffusion and point process observations.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"In particular, the following features are planned to be implemented in FeedbackParticleFilters:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Types for hidden state and observation models: diffusions, Poisson processes, etc.\nA variety of gain estimation methods\nAutomatic filter deployment and simulation of the state and filtering equations\nStoring of intermediate (trajectory) data from simulation\nAn interface to the powerful solvers from the DifferentialEquations package ","category":"page"},{"location":"getting_started/#Getting-started-1","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"getting_started/#Installation-1","page":"Getting started","title":"Installation","text":"","category":"section"},{"location":"getting_started/#","page":"Getting started","title":"Getting started","text":"Use the built-in package manager:","category":"page"},{"location":"getting_started/#","page":"Getting started","title":"Getting started","text":"using Pkg\nPkg.add(\"FeedbackParticleFilters\")","category":"page"},{"location":"getting_started/#Basic-usage-1","page":"Getting started","title":"Basic usage","text":"","category":"section"},{"location":"getting_started/#","page":"Getting started","title":"Getting started","text":"To load the package, use the command:","category":"page"},{"location":"getting_started/#","page":"Getting started","title":"Getting started","text":"using FeedbackParticleFilters","category":"page"},{"location":"getting_started/#","page":"Getting started","title":"Getting started","text":"Set up a basic one-dimensional linear-Gaussian continuous-time filtering problem:","category":"page"},{"location":"getting_started/#","page":"Getting started","title":"Getting started","text":"using Distributions\nstate_model = ScalarDiffusionStateModel(x->-x, x->sqrt(2.), Normal())\nobs_model   = ScalarDiffusionObservationModel(x->x)\n\nfilt_prob = ContinuousTimeFilteringProblem(state_model, obs_model)","category":"page"},{"location":"getting_started/#","page":"Getting started","title":"Getting started","text":"Once the filtering problem is defined, you can use it to perform a variety of tasks.","category":"page"},{"location":"getting_started/#","page":"Getting started","title":"Getting started","text":"For example, you may initialize an ensemble of N=100 particles:","category":"page"},{"location":"getting_started/#","page":"Getting started","title":"Getting started","text":"ensemble = UnweightedParticleEnsemble(state_model, 100)","category":"page"},{"location":"getting_started/#","page":"Getting started","title":"Getting started","text":"The following generates a Poisson equation for the gain using the ensemble above. The equation is solved using the semigroup gain estimation method.","category":"page"},{"location":"getting_started/#","page":"Getting started","title":"Getting started","text":"eq = GainEquation(state_model, obs_model, ensemble)\nmethod = SemigroupMethod(1E-1,1E-2)\nsolve!(eq, method)","category":"page"},{"location":"getting_started/#","page":"Getting started","title":"Getting started","text":"The gain at the particle locations is stored in eq.gain. These low-level building blocks can then be used to write custom numerical implementations. The package also comes with methods to automatically simulate a given filtering problem:","category":"page"},{"location":"getting_started/#","page":"Getting started","title":"Getting started","text":"filter = FPF(filt_prob, method, 100)\nsimulation = ContinuousTimeSimulation(filt_prob, filter, 10000, 0.01)\nrun!(simulation)","category":"page"},{"location":"filtering/#Brief-intro-to-filtering-1","page":"Brief intro to filtering","title":"Brief intro to filtering","text":"","category":"section"},{"location":"filtering/#","page":"Brief intro to filtering","title":"Brief intro to filtering","text":"Here's some inline maths: sqrtn1 + x + x^2 + ldots.","category":"page"},{"location":"filtering/#","page":"Brief intro to filtering","title":"Brief intro to filtering","text":"fracnk(n - k) = binomnk","category":"page"},{"location":"fpf/#Feedback-particle-filters-1","page":"Feedback particle filters","title":"Feedback particle filters","text":"","category":"section"},{"location":"hidden/#Hidden-state-models-1","page":"Hidden state models","title":"Hidden state models","text":"","category":"section"},{"location":"hidden/#","page":"Hidden state models","title":"Hidden state models","text":"CurrentModule = FeedbackParticleFilters","category":"page"},{"location":"hidden/#","page":"Hidden state models","title":"Hidden state models","text":"StateModel\npropagate!","category":"page"},{"location":"hidden/#FeedbackParticleFilters.propagate!","page":"Hidden state models","title":"FeedbackParticleFilters.propagate!","text":"propagate!(sfs, filtering_problem, filtering_algorithm; dt) --> sfs\n\nPropagates the system and filter states for one time-step according to the specified filtering problem and algorithm.\n\n\n\n\n\n","category":"function"},{"location":"hidden/#","page":"Hidden state models","title":"Hidden state models","text":"Pages = [\"hidden.md\"]","category":"page"},{"location":"hidden/#Diffusion-processes-1","page":"Hidden state models","title":"Diffusion processes","text":"","category":"section"},{"location":"hidden/#","page":"Hidden state models","title":"Hidden state models","text":"DiffusionStateModel\nLinearDiffusionStateModel\nScalarDiffusionStateModel\ndrift_function\ndiffusion_function\ninitial_condition","category":"page"},{"location":"hidden/#FeedbackParticleFilters.LinearDiffusionStateModel","page":"Hidden state models","title":"FeedbackParticleFilters.LinearDiffusionStateModel","text":"LinearDiffusionStateModel(f::Function, g::Function; init)\n\nA diffusion process hidden state model dX_t = f(X_t)dt + g(X_t)dW_t, where f is the drift_function, g is the observation_function, Xt is the n-dimensional hidden state at time t, and Wt is an m-dimensional Brownian motion process.\n\nOptional argument init stands for the initial condition of the process, which is either\n\nA vector of length n for a fixed (deterministic) initial condition\nA Distributions.Sampleable type for a random initial condition\n\nIf argument init is left out, it is set to either \n\na multivariate normal distribution with covariance matrix set to the stationary variance, if it exists\nthe zero vector\n\n\n\n\n\n","category":"type"},{"location":"observation/#Observation-models-1","page":"Observation models","title":"Observation models","text":"","category":"section"},{"location":"observation/#","page":"Observation models","title":"Observation models","text":"CurrentModule = FeedbackParticleFilters","category":"page"},{"location":"observation/#","page":"Observation models","title":"Observation models","text":"ObservationModel\nemit!","category":"page"},{"location":"observation/#FeedbackParticleFilters.ObservationModel","page":"Observation models","title":"FeedbackParticleFilters.ObservationModel","text":"ObservationModel{S1, S2, T} <: AbstractModel{S2}\n\nAbstract type for any model of observations of type S2 and hidden states of type S1.\n\nCalling the model samples a new observation. For discrete-time or static models, \n\nmodel(x)\n\nreturns a new observation based on hidden state x.\n\nFor continuous-time models,\n\nmodel(x, dt)\n\nreturns a new observation based on hidden state x and time-step dt.\n\nIf x is a vector of state_type elements or a batch matrix, an observation is generated for each element of the batch.\n\n\n\n\n\n","category":"type"},{"location":"observation/#","page":"Observation models","title":"Observation models","text":"Pages = [\"observation.md\"]","category":"page"},{"location":"observation/#Diffusion-processes-1","page":"Observation models","title":"Diffusion processes","text":"","category":"section"},{"location":"observation/#","page":"Observation models","title":"Observation models","text":"DiffusionObservationModel\nLinearDiffusionObservationModel\nScalarDiffusionObservationModel\nobservation_function","category":"page"},{"location":"gainest/#Gain-estimation-1","page":"Gain estimation","title":"Gain estimation","text":"","category":"section"},{"location":"gainest/#","page":"Gain estimation","title":"Gain estimation","text":"CurrentModule = FeedbackParticleFilters","category":"page"},{"location":"gainest/#","page":"Gain estimation","title":"Gain estimation","text":"GainEquation\nGainEstimationMethod\nsolve!\nupdate!","category":"page"},{"location":"gainest/#FeedbackParticleFilters.solve!","page":"Gain estimation","title":"FeedbackParticleFilters.solve!","text":"solve!(eq::GainEquation, method::GainEstimationMethod) --> eq\n\nSolves the gain equation eq using method method.\n\n\n\n\n\n","category":"function"},{"location":"gainest/#FeedbackParticleFilters.update!","page":"Gain estimation","title":"FeedbackParticleFilters.update!","text":"update!(filter_state, filter_algo, obs, dt) --> filter_state\n\nUpdates the filter state by performing one forward step of the model and then assimilating the observation. \n\n\n\n\n\nupdate!(eq::GainEquation)\n\nUpdates the gain equation eq.\n\nupdate!(eq::GainEquation, ens::ParticleRepresentation)\n\nUpdates the gain equation eq by incorporating new information from the ensemble ens.\n\n\n\n\n\n","category":"function"},{"location":"gainest/#","page":"Gain estimation","title":"Gain estimation","text":"Pages = [\"gainest.md\"]","category":"page"},{"location":"gainest/#Poisson-equation-1","page":"Gain estimation","title":"Poisson equation","text":"","category":"section"},{"location":"gainest/#","page":"Gain estimation","title":"Gain estimation","text":"PoissonEquation","category":"page"},{"location":"gainest/#Gain-estimation-methods-1","page":"Gain estimation","title":"Gain estimation methods","text":"","category":"section"},{"location":"gainest/#","page":"Gain estimation","title":"Gain estimation","text":"ConstantGainApproximation\nSemigroupMethod\nDifferentialRKHSMethod","category":"page"},{"location":"gainest/#FeedbackParticleFilters.ConstantGainApproximation","page":"Gain estimation","title":"FeedbackParticleFilters.ConstantGainApproximation","text":"ConstantGainApproximation()\n\nRepresents an approximation of the gain by a constant (in the Euclidean sense) vector field, given by the covariance of the observation function and x under the particle distribution.\n\n\n\n\n\n","category":"type"},{"location":"gainest/#FeedbackParticleFilters.SemigroupMethod","page":"Gain estimation","title":"FeedbackParticleFilters.SemigroupMethod","text":"SemigroupMethod(epsilon, delta, max_iter)\n\nSemigroup method from Algorithm 1 in [1].\n\n[1] Taghvaei, A., & Mehta, P. G. (2016). Gain function approximation in the feedback particle filter. In 2016 IEEE 55th Conference on Decision and Control (CDC) (pp. 5446–5452). IEEE. https://doi.org/10.1109/CDC.2016.7799105\n\nSemigroupMethod(epsilon, delta, max_iter, lambda)\n\nSemigroup method with regularization parameter lambda.\n\n\n\n\n\n","category":"type"},{"location":"gainest/#FeedbackParticleFilters.DifferentialRKHSMethod","page":"Gain estimation","title":"FeedbackParticleFilters.DifferentialRKHSMethod","text":"DifferentialRKHSMethod1d(epsilon, lambda)\n\nDifferential loss reproducing kernel Hilbert space (RKHS) method from [1], Section III.\n\nParameters\n\nepsilon: variance of the Gaussian kernel, Eq. 17 in [1]\nlambda: regularization parameter, Eq. 20 in [1]\n\nReference\n\n[1] Radhakrishnan, A. & and Meyn, S. (2018). Feedback particle filter design using a differential-loss reproducing kernel Hilbert space. 2018 Annual American Control Conference (ACC). IEEE. https://doi.org/10.23919/ACC.2018.8431689\n\n\n\n\n\n","category":"type"}]
}
